---
title: C, C++ 면접 질문
date: 2024-10-10 12:00:00
categories: [Interview, Language]
tags: [C, C++, Language, Interview]
order : 11
published: true
---

## C, C++

### C와 C++의 차이를 설명해주세요

C 언어는 `절차 지향 프로그래밍 언어`이고  
C++은 `객체 지향 프로그래밍 언어`입니다.  

C 언어에서는 `구조체에서 함수 선언`을 할 수 없지만 C++ 에서는 가능합니다.

### \\n과 endl의 차이를 설명해주세요

\\n은 `출력 버퍼를 비우지 않고 줄 변경`을 하여 endl보다 빠르고  
endl은 `출력 버퍼를 비우지 줄 변경`을 하여 \\n보다 느립니다.

### malloc과 calloc, new의 차이를 설명해주세요

malloc은 `전달받은 크기만큼 메모리를 할당만 해줍니다.`

calloc은 `전달받은 크기만큼 메모리를 할당하고 메모리를 0으로 초기화해줍니다.`

new는 `생성하려는 자료형의 크기만큼 메모리를 할당하고 초기화합니다.`

### memcpy와 memmove의 차이를 설명해주세요

memcpy와 memmove 두 함수는 모두 `특정 메모리를 다른 메모리로 복사`할 때 사용됩니다.

memcpy는 `source의 내용을 바로 destination에 복사`하지만  
그렇기에 memcpy는 `겹침 현상`이 일어날 수 있지만  
memmove는 `source의 내용을 임시 공간에 저장한 후 destination에 복사`하기에   
memmove가 `memcpy보다 느리지만 겹침 현상으로부터 더 안전`하다고 할 수 있습니다.

### null과 nullptr의 차이를 설명해주세요

`NULL의 의미는 0으로 치환되어 상수로 취급`되어 처리됩니다.  
반면에 `nullptr은 포인터 취급`을 받아 포인터가 아닌 다른 값과의 비교를 하는 실수를 막을 수 있습니다.

### 프로그램 빌드 과정에 대해 설명해주세요

C와 C++의 프로그램 빌드 과정은  
`전처리`, `컴파일`, `어셈블`, `링크` 과정을 통해 실행가능한 파일로 빌드됩니다.

`전처리 단계`에서는 #으로 시작하는 `전처리 지시어를 처리`합니다.  
`컴파일 단계`에서는 `전처리된 소스 코드를 어셈블리어로 변경`합니다.  
`어셈블 단계`에서는 `어셈블리어를 0과 1로 이루어진 기계어`로 변경합니다.  
`링크 단계`에서는 `오브젝트 파일과 라이브러리를 결합시켜 실행가능한 프로그램을 생성`합니다.

## Struct와 Class

### Struct와 Class의 차이를 설명해주세요

struct는 `기본 접근 제한자가 public`이고  
class는 `기본 접근 제한자가 private`입니다.

## 생성자(Constructor), 소멸자(Destructor)

### 생성자에 대해 설명해주세요

생성자는 `객체 생성 시` 호출되는 함수로  
생성자를 이용하여 객체의 생성과 동시에 멤버 변수를 초기화 할 수 있습니다.  
생성자 함수는 클래스의 이름과 동일한 이름으로 구현됩니다.

```c++
class Pizza
{
    Pizza() // 생성자 선언
    {
    }
}
```

### 소멸자에 대해 설명해주세요

소멸자는 `객체 제거 시` 호출되는 함수로  
객체의 메모리 반환을 위해 사용합니다.  
소멸자 함수는 클래스의 이름 앞에 ~가 붙은 형태로 구현됩니다.

```c++
class Pizza
{
    ~Pizza()  // 소멸자 선언
    {
    }
}
```

###  C++에서 기본 생성자가 무엇인지 설명해주세요

기본 생성자는 `클래스 내에 생성자가 없다면 컴파일러에서 자동으로 선언`해주는 생성자를 뜻 합니다.  
이때 컴파일러에 생성자가 하나라도 선언되어있다면 기본 생성자는 생기지 않습니다.

## 오버로딩과 오버라이딩

### 오버로딩에 대해 설명해주세요

오버로딩은 함수 `매개변수의 타입, 개수, 순서를 다르게하여 같은 이름의 여러 함수를 정의`하는 것을 말합니다.  
오버로딩을 사용하여 `같은 함수 이름이지만 매개 변수에 따라 다른 함수가 호출`되게 할 수 있습니다.  
오버로딩을 사용하여 호출하게 될 함수는 `컴파일 단계에서 정해`집니다.

```c++
void Sum(int& a)
{
    a++;
}

int Sum(int a, int b)
{
    return a + b;
}

```

### 오버라이딩에 대해 설명해주세요

오버라이딩은 `파생 클래스에서 부모 클래스의 함수를 재정의`하는 것을 말합니다.  
override 키워드를 사용하여 `재정의된 함수임을 명시`할 수 있습니다.

```c++
class Parent
{
protected:
	virtual int Function(int value) 
	{
	}
};

class Child : public Parent
{
protected:
	virtual int Function(int value) override 
	{ 
		Parent::Function(value);
	}
};
```

## 키워드

### virtual에 대해 설명해주세요

virtual 키워드는 `파생클래스에서 재정의할 수도 있는 함수`에 사용됩니다.  
virtual 함수는 클래스의 생성 시 `virtual 테이블에 저장`되어   
가상 함수 호출 시 virtual 테이블에서 해당 함수를 찾아 호출합니다.

### volatile에 대해 설명해주세요

volatile 키워드는 `컴파일러가 해당 변수를 최적화에서 제외하여 항상 메모리에 접근`하도록 하는 키워드입니다.

### inline에 대해 설명해주세요

inline 키워드는 `컴파일러가 함수를 호출하는 대신`에   
`코드 자체를 호출된 위치에 삽입하도록 요청`하도록 하는 키워드입니다.  
그렇기에 `inline 함수는 다른 함수보다 빠르지만` 남용할 경우 `코드 비대화 문제가 일어날 수 있습니다.`

### const에 대해 설명해주세요

const 키워드는 `변수를 상수로 지정하여 초기값 외에 다른 값으로 변경할 수 없게하는 키워드`입니다.

### explict에 대해 설명해주세요

explict 키워드는 `묵시적 형변환을 막아주는 키워드`입니다.

## 함수

### 템플릿에 대해 설명해주세요

템플릿은 `데이터 타입을 일반화하여 코드 재사용성을 높이는 기능`입니다.  
`컴파일 타임에 구체적인 타입으로 인스턴스화됩니다.`

## 포인터와 참조자

### 포인터에 대해 설명해주세요

포인터는 `객체의 메모리 주소를 가지며 지정한 객체를 변경할 수 있습니다.`

### 참조자에 대해 설명해주세요

참조자는 포인터와 같이 `객체의 원본을 가집니다.`     
참조자는 `선언 시 반드시 처음에 변수를 할당해야하며 나중에 변경할 수 없습니다.`

## 스마트 포인터 

스마트 포인터는 `동적 메모리를 자동으로 관리`하는 클래스입니다.  

### shared_ptr에 대해 설명해주세요

shared_ptr은 `자신을 참조하는 객체의 수를 가지는 reference_count`를 가지고 있습니다.  
이 reference_count가 0이 될 경우 자동으로 할당을 해제합니다.

### unique_ptr에 대해 설명해주세요

unique_ptr은 `메모리에 대한 단독 소유권을 가지는` 스마트 포인터입니다.

### weak_ptr에 대해 설명 해주세요

weak_ptr은 `reference_count에 영향을 주지 않는` 스마트 포인터입니다.  
weak_ptr은 상호 참조 문제를 막기위해 사용합니다.